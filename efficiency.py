import itertools

def deegan_packel_score(inference_function, features):
    """
    Compute the Deegan-Packel score for a fixed set of features.
    
    Parameters:
    - inference_function: a function that takes a set of features and returns an outcome (prediction)
    - features: a list of features
    
    Returns:
    - A dictionary with Deegan-Packel scores for each feature
    """
    # Find all minimal winning coalitions (sets where removing any feature would change the outcome)
    minimal_coalitions = []
    for r in range(1, len(features) + 1):
        for coalition in itertools.combinations(features, r):
            if inference_function(set(coalition)) != 0:  # Non-zero value indicates a winning coalition
                minimal_coalitions.append(set(coalition))

    # Calculate Deegan-Packel scores
    deegan_packel_scores = {feature: 0 for feature in features}
    total_coalitions = len(minimal_coalitions)
    
    for coalition in minimal_coalitions:
        for feature in coalition:
            deegan_packel_scores[feature] += 1 / (len(coalition) * total_coalitions)
    
    return deegan_packel_scores

def check_efficiency(scores, inference_function, features):
    """
    Check the efficiency property of the scores.
    
    Parameters:
    - scores: A dictionary of feature importance scores
    - inference_function: A function that takes a set of features and returns an outcome (prediction)
    - features: A list of features
    
    Returns:
    - True if efficiency holds, False otherwise
    """
    # Compute the value of the grand coalition (all features)
    grand_coalition_value = inference_function(set(features))
    
    # Compute the value of the empty set (no features)
    empty_set_value = inference_function(set())
    
    # Sum of Deegan-Packel scores
    scores_sum = sum(scores.values())
    
    # Check if the sum of scores equals the difference (grand coalition - empty set)
    return abs(scores_sum - (grand_coalition_value - empty_set_value)) < 1e-6

# Define a simple inference function
def simple_inference_function(coalition):
    """
    A simple inference function that returns a value based on the coalition.
    """
    if 'A' in coalition and 'B' in coalition:
        return 3  # Value when A and B are present
    elif 'A' in coalition and 'C' in coalition:
        return 2  # Value when A and C are present
    elif 'B' in coalition and 'C' in coalition:
        return 2  # Value when B and C are present
    elif 'A' in coalition:
        return 1  # Value when only A is present
    elif 'B' in coalition:
        return 1  # Value when only B is present
    elif 'C' in coalition:
        return 1  # Value when only C is present
    else:
        return 0  # Value for the empty set

# Define the features
features = ['A', 'B', 'C']

# Calculate the Deegan-Packel scores
dp_scores = deegan_packel_score(simple_inference_function, features)

# Print Deegan-Packel scores
print("Deegan-Packel scores:")
for feature, value in dp_scores.items():
    print(f"Feature {feature}: {value:.2f}")

# Check if efficiency is violated
efficiency_violated = not check_efficiency(dp_scores, simple_inference_function, features)

print(f"\nEfficiency violated: {efficiency_violated}")

# Explain the impact of the violation
def demonstrate_violation_impact():
    print("\nImpact of Efficiency Violation:")
    print("The Deegan-Packel score, by focusing on minimal winning coalitions,")
    print("may not distribute the total value among all features correctly.")
    print("This can result in a sum of feature importance scores that doesn't")
    print("equal the total value generated by the grand coalition.")

demonstrate_violation_impact()
